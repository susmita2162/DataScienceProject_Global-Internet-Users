{
  "hash": "b36100ff24d4de6a41567f356be591c4",
  "result": {
    "markdown": "---\ntitle: \"Visualizing Multiple Dimensions\"\nauthor: \"Susmita Madineni\"\ndescription: \"Visualizing Multiple Dimensions\"\ndate: \"08/24/2022\"\nformat:\n  html:\n    toc: true\n    code-copy: true\n    code-tools: true\ncategories:\n  - challenge_7\n  - australian_marriage\n  - readr\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggplot2)\n\nknitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)\n```\n:::\n\n\n## Challenge Overview\n\nToday's challenge is to:\n\n1)  read in a data set, and describe the data set using both words and any supporting information (e.g., tables, etc)\n2)  tidy data (as needed, including sanity checks)\n3)  mutate variables as needed (including sanity checks)\n4)  Recreate at least two graphs from previous exercises, but introduce at least one additional dimension that you omitted before using ggplot functionality (color, shape, line, facet, etc) The goal is not to create unneeded [chart ink (Tufte)](https://www.edwardtufte.com/tufte/), but to concisely capture variation in additional dimensions that were collapsed in your earlier 2 or 3 dimensional graphs.\n   - Explain why you choose the specific graph type\n5) If you haven't tried in previous weeks, work this week to make your graphs \"publication\" ready with titles, captions, and pretty axis labels and other viewer-friendly features\n\n## Read in data\n\nRead in one (or more) of the following datasets, using the correct R package and command.\n\n  - eggs ⭐\n  - abc_poll ⭐⭐\n  - australian_marriage ⭐⭐\n  - hotel_bookings ⭐⭐⭐\n  - air_bnb  ⭐⭐⭐\n  - us_hh ⭐⭐⭐⭐\n  - faostat ⭐⭐⭐⭐⭐\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\naumg_data <- read_csv(\"_data/australian_marriage_tidy.csv\")\nView(aumg_data)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Preview the first few rows of the dataset\nhead(aumg_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  territory       resp    count percent\n  <chr>           <chr>   <dbl>   <dbl>\n1 New South Wales yes   2374362    57.8\n2 New South Wales no    1736838    42.2\n3 Victoria        yes   2145629    64.9\n4 Victoria        no    1161098    35.1\n5 Queensland      yes   1487060    60.7\n6 Queensland      no     961015    39.3\n```\n:::\n\n```{.r .cell-code}\n# Understanding the dimensions of the dataset \ndim(aumg_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16  4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identifying the column names of the dataset \ncolnames(aumg_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"territory\" \"resp\"      \"count\"     \"percent\"  \n```\n:::\n\n```{.r .cell-code}\n# Identifying the data types of the columns\nsapply(aumg_data, class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  territory        resp       count     percent \n\"character\" \"character\"   \"numeric\"   \"numeric\" \n```\n:::\n\n```{.r .cell-code}\ntable(sapply(aumg_data, function(x) typeof(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\ncharacter    double \n        2         2 \n```\n:::\n\n```{.r .cell-code}\nsapply(aumg_data, function(x) n_distinct(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nterritory      resp     count   percent \n        8         2        16        16 \n```\n:::\n:::\n\n\n### Briefly describe the data\n\nThe dataset gives the information about marriages in different parts of Australia. There are 16 rows and 4 columns. Based on the above, we can infer that there are 2 characters and 2 double datatypes. All the columns are readable for the user. Each observation in the dataset provides information of territory, response(yes/no), count(number of people who responded whether they're married or not) and the respective percentage. \n\n\n## Tidy Data (as needed)\n\nThe data is tidy enough to work on. I would like to mutate the dataset to understand the count of people responded as yes in different territories and also no in different territories separately and understand how the rates of marriages varies across the territories. To plot this, I would want the total population in every territory and the respective percentage across the territories.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmarried_no <- aggregate(count ~ territory, data = aumg_data, FUN = sum)\nmarried_no\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                        territory   count\n1 Australian Capital Territory(c)  236979\n2                 New South Wales 4111200\n3           Northern Territory(b)   80376\n4                      Queensland 2448075\n5                 South Australia  948775\n6                        Tasmania  301603\n7                        Victoria 3306727\n8               Western Australia 1257499\n```\n:::\n\n```{.r .cell-code}\nmarried_no['Resp_no%'] <- subset(aumg_data, resp ==\"no\")['percent']\nmarried_no\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                        territory   count Resp_no%\n1 Australian Capital Territory(c)  236979     42.2\n2                 New South Wales 4111200     35.1\n3           Northern Territory(b)   80376     39.3\n4                      Queensland 2448075     37.5\n5                 South Australia  948775     36.3\n6                        Tasmania  301603     36.4\n7                        Victoria 3306727     39.4\n8               Western Australia 1257499     26.0\n```\n:::\n\n```{.r .cell-code}\nmarried_yes <- aggregate(count ~ territory, data = aumg_data, FUN = sum)\nmarried_yes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                        territory   count\n1 Australian Capital Territory(c)  236979\n2                 New South Wales 4111200\n3           Northern Territory(b)   80376\n4                      Queensland 2448075\n5                 South Australia  948775\n6                        Tasmania  301603\n7                        Victoria 3306727\n8               Western Australia 1257499\n```\n:::\n\n```{.r .cell-code}\nmarried_yes['Resp_yes%'] <- subset(aumg_data, resp ==\"yes\")['percent']\nmarried_yes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                        territory   count Resp_yes%\n1 Australian Capital Territory(c)  236979      57.8\n2                 New South Wales 4111200      64.9\n3           Northern Territory(b)   80376      60.7\n4                      Queensland 2448075      62.5\n5                 South Australia  948775      63.7\n6                        Tasmania  301603      63.6\n7                        Victoria 3306727      60.6\n8               Western Australia 1257499      74.0\n```\n:::\n:::\n\n\n## Visualization with Multiple Dimensions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(married_no, aes(x=`count`, y= `Resp_no%`, color = `territory`))+ \n  geom_point()+\n  geom_line(color = \"#69b3a2\")+\n  theme_minimal() + \n  labs(title = \"Unmarried Vs Population across territories\", y = \"Unmarried percentage\", x = \"Population of the Territory\")\n```\n\n::: {.cell-output-display}\n![](SusmitaMadineni_challenge7_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(married_yes, aes(x=`count`, y= `Resp_yes%`, color = `territory`))+ \n  geom_point()+\n  geom_line(color = \"#69b3a2\")+\n  theme_minimal() + labs(title = \"Married Vs Population across territories\", y = \"Married percentage\", x = \"Population of the Territory\")\n```\n\n::: {.cell-output-display}\n![](SusmitaMadineni_challenge7_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\nBased on the above :\nIn the first scenario(Unmarried Vs Population across territories), the percentage of people responded as no is varying from as low as around 7% to 65% and in second scenario(Married Vs Population across territories), the percentage of people responded as yes is varying from around 55% to 75%. In both cases above, Western Australia looks like an outlier at the lower ends and Australian Capital Territory looks like an outlier at the higher end among all the territories.\n",
    "supporting": [
      "SusmitaMadineni_challenge7_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}